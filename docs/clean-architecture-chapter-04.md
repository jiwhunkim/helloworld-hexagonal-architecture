# chapter 04 유스케이스 구현하기

- 애플리케이션, 웹, 영속성 계층이 현재 아키텍처에서 아주 느슨하게 결합돼 있기 때문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다. DDD를 할 수돋 있고, 풍부하거나 빈약한 도메인 모델을 구현할 수도 있고, 우리만의 방식을 만들어 낼 수도 있다.

## 유스케이스 둘러보기
- 유스케이스는 비즈니스 규칙을 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.
- 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다. 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.

## 생성자의 힘
- 하지만 빌더 뒤에 숨기는 대신 생성자를 직접 사용했다면 새로운 필드를 추가하거나 필드를 삭제할 때마다 컴파일 에러를 따라 나머지 코드에 변경사항을 반여영할 수 있었을 것이다.

## 유스케이스마다 다른 입력 모델
- 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다. 물론 비용이 안드는 것은 아니다. 들어오는 데이터를 각 유스케이스에 해당하는 입력 모델과 매핑해야 하기 때문이다.

## 비즈니스 규칙 검증하기
- 입력 유효성을 검증하는 것은 구문상의 유효성을 검증하는 것이라고 할 수 있다. 반면 비즈니스 규칙은 유스케이스 맥락 속에서 의미적인 유효성을 검증하는 일이라고 할 수 있다.

## 풍부한 도메인 모델 vs 빈약한 도메인 모델
- 풍부한 도메인 모델에서는 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다. 엔티티들은 상태를 변경하는 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.
- 빈약한 도메인 모델에서는 엔티티 자체가 굉장히 얇다. 일반적으로 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한, getter, setter 메서드만 포함하고 어떠한 도메인 로직도 가지고 있지 않다.

## 유스케이스마다 다른 출력 모델
- 유스케잇드르 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다. 한 유스케이스에서 출력 모델에 새로운 필드가 필요해지면 이 값과 관련이 없는 다른 유스케이스에서도 이 필드를 처리해야 한다. 공유 모델은 장기적으로 봤을 때 갖가지 이유로 점점 커지게 돼 있다. 단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것은 유스케이스의 결합을 제거하는데 도움이 된다.

## 읽기 전용 유스케이스는 어떨까?
- 읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드 상에서 명확하게 구분된다. 이런 방식은 CQS 나 CQRS 같은 개념과 아주 잘 맞는다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 유스케이스별로 모델을 만들면 유스케이스를 명확하게 이해할 수 있고, 장기적으로 유지보수하기도 더 쉽다. 또한 여러명의 개발자가 다른 사람이 작업중인 유스케잇르르 건드리지 않은 채로 여러 개의 유스케이스를 동시에 작업할 수 있다.
